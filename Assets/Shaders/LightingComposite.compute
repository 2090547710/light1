#pragma kernel CSObstacleLight
#pragma kernel CSNormalLight

Texture2D<float> _HeightMap;
RWTexture2D<float4> _CompositeMap;

float4 _LightBounds; // x,y: min点, z,w: max点
float4 _RootBounds; // x,y: center, z,w: size
float _IsObstacle;
float _LightHeight;

[numthreads(16,16,1)]
void CSObstacleLight(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    _HeightMap.GetDimensions(width, height);
    
    if(id.x >= width || id.y >= height) return;
    
    // 计算世界空间UV
    float2 uv = float2(id.xy) / float2(width-1, height-1);
    float2 targetUV = lerp(_LightBounds.xy, _LightBounds.zw, uv);
    
    // 计算合成图坐标
    uint compositeWidth, compositeHeight;
    _CompositeMap.GetDimensions(compositeWidth, compositeHeight);
    
    uint2 pixelCoord = uint2(
        targetUV.x * (compositeWidth-1),
        targetUV.y * (compositeHeight-1)
    );
    
    // 障碍物写入绿色通道
    float objectHeight = _HeightMap[id.xy].r;
    float4 compositeData = _CompositeMap[pixelCoord];  // 读取完整数据
    float newHeight = saturate(compositeData.g + objectHeight); //叠加并限制在0-1之间
    compositeData.g = newHeight;  // 只修改绿色通道
    _CompositeMap[pixelCoord] = compositeData;  // 完整写入所有通道
}

[numthreads(16,16,1)]
void CSNormalLight(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    _HeightMap.GetDimensions(width, height);
    
    if(id.x >= width || id.y >= height) return;
    
    // 计算世界空间UV
    float2 uv = float2(id.xy) / float2(width-1, height-1);
    float2 targetUV = lerp(_LightBounds.xy, _LightBounds.zw, uv);
    
    // 计算合成图坐标
    uint compositeWidth, compositeHeight;
    _CompositeMap.GetDimensions(compositeWidth, compositeHeight);
    
    uint2 pixelCoord = uint2(
        targetUV.x * (compositeWidth-1),
        targetUV.y * (compositeHeight-1)
    );
    
    // 获取当前像素值
    float objectHeight = _HeightMap[id.xy].r;
    if(objectHeight < 0.01f) return;
    
    float obstacleHeight = _CompositeMap[pixelCoord].g;
    float4 compositeData = _CompositeMap[pixelCoord];  // 读取完整数据
    
    // 只有当光源高度大于障碍物且亮度足够时才写入
    if(_LightHeight >= obstacleHeight) {
        float newHeight = saturate(compositeData.r + objectHeight); //叠加并限制在0-1之间
        compositeData.r = newHeight;  // 修改红色通道
        _CompositeMap[pixelCoord] = compositeData;  // 完整写入所有通道
    }
}
